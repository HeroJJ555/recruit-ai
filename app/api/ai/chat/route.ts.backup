import { NextRequest, NextResponse } from "next/server"
i    import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth"
import { authOptions } from "@/lib/auth"
import { prisma } from "@/lib/prisma"

type ChatMessage = {
  role: 'system' | 'user' | 'assistant'
  content: string
}

type ChatRequest = {
  messages: ChatMessage[]
  temperature?: number
  maxTokens?: number
}

async function getDatabaseContext(): Promise<string> {
  try {
    // Pobierz podstawowe statystyki
    const [candidatesCount, jobsCount, analysesCount] = await Promise.all([
      (prisma as any).candidateApplication.count(),
      (prisma as any).job.count({ where: { status: 'OPEN' } }),
      (prisma as any).cvAnalysis.count()
    ])

    // Pobierz przykładowe dane
    const [recentCandidates, activeJobs] = await Promise.all([
      (prisma as any).candidateApplication.findMany({
        take: 3,
        orderBy: { createdAt: 'desc' },
        include: { cvAnalysis: true },
        select: {
          firstName: true,
          lastName: true,
          position: true,
          cvAnalysis: {
            select: {
              matchScore: true,
              summary: true
            }
          }
        }
      }),
      (prisma as any).job.findMany({
        take: 3,
        where: { status: 'OPEN' },
        select: {
          title: true,
          department: true,
          seniority: true
        }
      })
    ])

    let context = "=== KONTEKST SYSTEMU REKRUTACYJNEGO ===\\n"
    context += `Statystyki: ${candidatesCount} kandydatów, ${jobsCount} aktywnych ofert, ${analysesCount} analiz CV\\n\\n`
    
    if (recentCandidates.length > 0) {
      context += "Ostatni kandydaci:\\n"
      recentCandidates.forEach((c: any, i: number) => {
        context += `${i + 1}. ${c.firstName} ${c.lastName} - ${c.position}`
        if (c.cvAnalysis?.matchScore) {
          context += ` (${c.cvAnalysis.matchScore.toFixed(1)}% dopasowania)`
        }
        context += "\\n"
      })
      context += "\\n"
    }

    if (activeJobs.length > 0) {
      context += "Aktywne oferty pracy:\\n"
      activeJobs.forEach((j: any, i: number) => {
        context += `${i + 1}. ${j.title} - ${j.department || 'Brak działu'} (${j.seniority || 'Dowolny poziom'})\\n`
      })
    }

    return context
  } catch (error) {
    console.error('Błąd pobierania kontekstu z bazy:', error)
    return "System rekrutacyjny z analizą CV i zarządzaniem kandydatami."
  }
}

async function callOpenAI(messages: ChatMessage[], dbContext: string, temperature = 0.7, maxTokens = 1000): Promise<string> {
  try {
    const apiKey = process.env.OPENAI_API_KEY
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY nie jest skonfigurowany')
    }

    console.log('=== Wywołanie OpenAI API ===')
    
    // Dodaj kontekst systemowy z bazą danych
    const systemMessage = {
      role: 'system' as const,
      content: `Jesteś profesjonalnym asystentem AI specjalizującym się w rekrutacji i HR. Odpowiadaj po polsku, zwięźle i konkretnie.

WAŻNE ZASADY:
- NIE używaj markdown'u (bez **, ##, - itp.)
- Pisz prostym tekstem jak SMS
- Odpowiadaj naturalnie, jak w rozmowie

Masz dostęp do danych z systemu:
${dbContext}

Udzielaj praktycznych porad dotyczących rekrutacji, oceny kandydatów, opisów stanowisk i rozmów kwalifikacyjnych. Odnosź się do konkretnych danych gdy to możliwe.`
    }

    const allMessages = [systemMessage, ...messages]
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: allMessages,
        temperature: temperature,
        max_tokens: maxTokens,
      }),
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}))
      throw new Error(`OpenAI API błąd ${response.status}: ${errorData.error?.message || response.statusText}`)
    }

    const data = await response.json()
    const content = data.choices?.[0]?.message?.content || ''
    
    console.log('OpenAI odpowiedź:', content.length, 'znaków')
    
    if (!content || content.length < 2) {
      return "Jestem asystentem rekrutacyjnym. W czym mogę pomóc?"
    }
    
    return content.trim()
    
  } catch (error) {
    console.error('OpenAI API błąd:', error)
    throw error
  }
}

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const body: ChatRequest = await req.json()
    
    if (!body.messages || !Array.isArray(body.messages) || body.messages.length === 0) {
      return NextResponse.json({ error: "Messages array is required" }, { status: 400 })
    }

    const temperature = Math.max(0, Math.min(1, body.temperature || 0.7))
    const maxTokens = Math.max(50, Math.min(2048, body.maxTokens || 1000))

    console.log('Chat request:', { 
      messageCount: body.messages.length, 
      temperature, 
      maxTokens,
      userEmail: session.user?.email 
    })

    // Pobierz kontekst z bazy danych
    const dbContext = await getDatabaseContext()

    const answer = await callOpenAI(body.messages, dbContext, temperature, maxTokens)

    return NextResponse.json({ 
      answer,
      model: "gpt-4o-mini",
      temperature,
      maxTokens
    })

  } catch (error) {
    console.error('Chat API error:', error)
    
    const fallbackResponse = "Cześć! Jestem asystentem AI ds. rekrutacji. Mogę pomóc z pisaniem opisów stanowisk, przygotowaniem pytań na rozmowy kwalifikacyjne lub oceną kandydatów. Napisz, w czym mogę pomóc!"
    
    return NextResponse.json({ 
      answer: fallbackResponse,
      model: "fallback",
      error: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}ServerSession } from "next-auth"
import { authOptions } from "@/lib/auth"
import { prisma } from "@/lib/prisma"

type ChatMessage = {
  role: 'system' | 'user' | 'assistant'
  content: string
}

type ChatRequest = {
  messages: ChatMessage[]
  temperature?: number
  maxTokens?: number
}

async function getDatabaseContext(): Promise<string> {
  try {
    // Pobierz podstawowe statystyki
    const [candidatesCount, jobsCount, analysesCount] = await Promise.all([
      (prisma as any).candidateApplication.count(),
      (prisma as any).job.count({ where: { status: 'OPEN' } }),
      (prisma as any).cvAnalysis.count()
    ])

    // Pobierz przykładowe dane
    const [recentCandidates, activeJobs] = await Promise.all([
      (prisma as any).candidateApplication.findMany({
        take: 3,
        orderBy: { createdAt: 'desc' },
        include: { cvAnalysis: true },
        select: {
          firstName: true,
          lastName: true,
          position: true,
          cvAnalysis: {
            select: {
              matchScore: true,
              summary: true
            }
          }
        }
      }),
      (prisma as any).job.findMany({
        take: 3,
        where: { status: 'OPEN' },
        select: {
          title: true,
          department: true,
          seniority: true
        }
      })
    ])

    let context = "=== KONTEKST SYSTEMU REKRUTACYJNEGO ===\n"
    context += `Statystyki: ${candidatesCount} kandydatów, ${jobsCount} aktywnych ofert, ${analysesCount} analiz CV\n\n`
    
    if (recentCandidates.length > 0) {
      context += "Ostatni kandydaci:\n"
      recentCandidates.forEach((c: any, i: number) => {
        context += `${i + 1}. ${c.firstName} ${c.lastName} - ${c.position}"
        if (c.cvAnalysis?.matchScore) {
          context += ` (${c.cvAnalysis.matchScore.toFixed(1)}% dopasowania)"
        }
        context += "\n"
      })
      context += "\n"
    }

    if (activeJobs.length > 0) {
      context += "Aktywne oferty pracy:\n"
      activeJobs.forEach((j: any, i: number) => {
        context += `${i + 1}. ${j.title} - ${j.department || 'Brak działu'} (${j.seniority || 'Dowolny poziom'})\n`
      })
    }

    return context
  } catch (error) {
    console.error('Błąd pobierania kontekstu z bazy:', error)
    return "System rekrutacyjny z analizą CV i zarządzaniem kandydatami."
  }
}

async function callOpenAI(messages: ChatMessage[], dbContext: string, temperature = 0.7, maxTokens = 1000): Promise<string> {
  try {
    const apiKey = process.env.OPENAI_API_KEY
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY nie jest skonfigurowany')
    }

    console.log('=== Wywołanie OpenAI API ===')
    
    // Dodaj kontekst systemowy z bazą danych
    const systemMessage = {
      role: 'system' as const,
      content: `Jesteś profesjonalnym asystentem AI specjalizującym się w rekrutacji i HR. Odpowiadaj po polsku, zwięźle i konkretnie.

WAŻNE ZASADY:
- NIE używaj markdown'u (bez **, ##, - itp.)
- Pisz prostym tekstem jak SMS
- Odpowiadaj naturalnie, jak w rozmowie

Masz dostęp do danych z systemu:
${dbContext}

Udzielaj praktycznych porad dotyczących rekrutacji, oceny kandydatów, opisów stanowisk i rozmów kwalifikacyjnych. Odnosź się do konkretnych danych gdy to możliwe.`
    }

    const allMessages = [systemMessage, ...messages]
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: allMessages,
        temperature: temperature,
        max_tokens: maxTokens,
      }),
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}))
      throw new Error(`OpenAI API błąd ${response.status}: ${errorData.error?.message || response.statusText}`)
    }

    const data = await response.json()
    const content = data.choices?.[0]?.message?.content || ''
    
    console.log('OpenAI odpowiedź:', content.length, 'znaków')
    
    if (!content || content.length < 2) {
      return "Jestem asystentem rekrutacyjnym. W czym mogę pomóc?"
    }
    
    return content.trim()
    
  } catch (error) {
    console.error('OpenAI API błąd:', error)
    throw error
  }
}

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const body: ChatRequest = await req.json()
    
    if (!body.messages || !Array.isArray(body.messages) || body.messages.length === 0) {
      return NextResponse.json({ error: "Messages array is required" }, { status: 400 })
    }

    const temperature = Math.max(0, Math.min(1, body.temperature || 0.7))
    const maxTokens = Math.max(50, Math.min(2048, body.maxTokens || 1000))

    console.log('Chat request:', { 
      messageCount: body.messages.length, 
      temperature, 
      maxTokens,
      userEmail: session.user?.email 
    })

    // Pobierz kontekst z bazy danych
    const dbContext = await getDatabaseContext()

    const answer = await callOpenAI(body.messages, dbContext, temperature, maxTokens)

    return NextResponse.json({ 
      answer,
      model: "gpt-4o-mini",
      temperature,
      maxTokens
    })

  } catch (error) {
    console.error('Chat API error:', error)
    
    const fallbackResponse = "Cześć! Jestem asystentem AI ds. rekrutacji. Mogę pomóc z pisaniem opisów stanowisk, przygotowaniem pytań na rozmowy kwalifikacyjne lub oceną kandydatów. Napisz, w czym mogę pomóc!"
    
    return NextResponse.json({ 
      answer: fallbackResponse,
      model: "fallback",
      error: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}