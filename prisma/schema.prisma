// Prisma schema for NextAuth with Credentials and Google
// Using SQLite for local development

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  // Use a direct (non-pooled) connection for migrations/introspection (bypasses PgBouncer on Supabase)
  directUrl = env("DIRECT_URL")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  // Credentials auth
  passwordHash  String?

  accounts              Account[]
  sessions              Session[]
  candidateApplications CandidateApplication[]
  jobs                  Job[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CandidateApplication {
  id     String  @id @default(cuid())
  userId String? // Optional link to authenticated user
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)
  jobId  String?
  job    Job?    @relation(fields: [jobId], references: [id], onDelete: SetNull)

  firstName String
  lastName  String
  email     String
  phone     String?

  position   String
  experience String // junior | mid | senior | lead
  skills     String // comma-separated or free text
  education  String?

  // CV file metadata (prefer object storage e.g., Supabase Storage); keep cvFileData optional for legacy
  cvFileName String?
  cvFileType String?
  cvFileSize Int?
  cvFileData Bytes?

  // AI Analysis relationship
  cvAnalysis CvAnalysis?

  // NOTE: Object storage info temporarily removed until database migration can be applied
  // storageProvider String?  @default("supabase")
  // storageBucket   String?
  // storageKey      String?
  // fileHash        String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([email])
  @@index([createdAt])
  @@index([position])
  // @@index([storageKey])  // Commented out until storage fields are migrated
}

model CvAnalysis {
  id                    String                @id @default(cuid())
  candidateApplicationId String               @unique
  candidateApplication  CandidateApplication @relation(fields: [candidateApplicationId], references: [id], onDelete: Cascade)

  // Raw extracted text from CV
  analyzedText         String?

  // AI Generated analysis fields
  summary              String? // Polish natural language summary
  technicalSkills      Json?   // Array of skills with match indicators  
  experienceYears      Int?    // Extracted years of experience
  matchScore           Float?  // Compatibility percentage (0-100)
  interviewQuestions   Json?   // Array of personalized interview questions

  // Metadata
  aiProvider           String? @default("openai") // Track which AI generated this
  aiModel              String? @default("gpt-4o-mini")
  tokenUsage           Int?    // Token consumption for this analysis
  processingTimeMs     Int?    // Time taken for analysis

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@index([candidateApplicationId])
  @@index([matchScore])
  @@index([createdAt])
}

enum JobStatus {
  DRAFT
  OPEN
  PAUSED
  CLOSED
}

model Job {
  id               String                 @id @default(cuid())
  title            String
  slug             String                 @unique
  department       String?
  location         String?
  employmentType   String? // np. full-time, contract
  seniority        String? // junior | mid | senior | lead
  description      String
  requirements     String?
  responsibilities String?
  benefits         String?
  // Ideal candidate profile for compatibility scoring
  goldenCandidate  Json?
  status           JobStatus              @default(DRAFT)
  openings         Int                    @default(1)
  publishedAt      DateTime?
  ownerId          String?
  owner            User?                  @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  applications     CandidateApplication[]
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  @@index([status])
  @@index([publishedAt])
  @@index([ownerId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @map("refreshToken")
  access_token      String? @map("accessToken")
  expires_at        Int?    @map("expiresAt")
  token_type        String? @map("tokenType")
  scope             String?
  id_token          String? @map("idToken")
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
